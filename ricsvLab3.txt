In RISC implement:
a) Read array, takes param(N), reads numbers until 0 is input and stores them continuosly in memory, starting with location N
        INP R0, 2
        MOV R7, R0
        JMS readArr
readArr INP R1, 2
        CMP R1, #0
        BEQ rdLpEnd
        STR R1, 0(R0)
        ADD R0, #1
        BRA readArr
rdLpEnd MOV R6, R0
        SUB R6, R6, R7
        RET

b) Print array, takes 2 params(N = starting position, M = array length) and outputs M numbers starting at position N as hex.
        INP R0, 2
        MOV R7, R0
        JMS readArr
printArr MOV R0, R7
        MOV R2, R6
prLp    LDR R1, 0(R0)
        OUT R1, 6
        ADD R0, #1
        SUB R2, #1
        CMP R2, #0
        BNE prLp
        RET

c) minmax: Takes (N, M); returns min and max value of array starting at N
        INP R0, 2
        MOV R7, R0
        JMS readArr
minmax  MOV R0, R7
        MOV R2, R6
        LDR R5, 0(R0)
        MOV R4, R5
mmLoop  ADD R0, #1
        SUB R2, #1
        CMP R2, #0
        BEQ mmEnd
        LDR R3, 0(R0)
        CMP R3, R5
        BGT gt
        BRA notGt
gt      MOV R5, R3
notGt   CMP R3, R4
        BLT lt
        BRA notLt
lt      MOV R4, R3
notLt   BRA mmLoop
mmEnd   OUT R5
        OUT R4
        RET

d) Print value: Receives 1 param, outputs param test with c

e) Duplicate array: Params (N, M, K); Duplicates array of length M starting at N into K (K = starting position in memory), eliminating min and max values
        INP R0, 2
        MOV R7, R0
        JMS readArr
dup     MOV R0, R7
        MOV R2, R6
        INP R1, 2
dupLoop LDR R3, 0(R0)
        STR R3, 0(R1)
        ADD R0, #1
        ADD R1, #1
        SUB R2, #1
        CMP R2, #0
        BEQ dupLpEnd
        BRA dupLoop
dupLpEnd RET

f) Factorial: Params (N); calculates factorial(N) recursively through stack; returns factorial(N)
        INP R0, 2 
        MOV R7, R0
stPush  CMP R0, #1
        BEQ endPush
        PSH R0
        SUB R0, #1
        BRA stPush
endPush MOV R2, #1
stPop   POP R3
        MOV R4, R3
        MLX R2, R4
        CMP R7, R3
        BNE stPop
        OUT R2
        HLT


// 1, 2, 3, 4, 5 intr-un singur proiect
        INP R0, 2
        MOV R7, R0
        JMS readArr
        JMS printArr
        JMS minmax
        JMS dup
        HLT
readArr INP R1, 2
        CMP R1, #0
        BEQ rdLpEnd
        STR R1, 0(R0)
        ADD R0, #1
        BRA readArr
rdLpEnd MOV R6, R0
        SUB R6, R6, R7
        RET
printArr MOV R0, R7
        MOV R2, R6
prLp    LDR R1, 0(R0)
        OUT R1, 6
        ADD R0, #1
        SUB R2, #1
        CMP R2, #0
        BNE prLp
        RET
minmax  MOV R0, R7
        MOV R2, R6
        LDR R5, 0(R0)
        MOV R4, R5
mmLoop  ADD R0, #1
        SUB R2, #1
        CMP R2, #0
        BEQ mmEnd
        LDR R3, 0(R0)
        CMP R3, R5
        BGT gt
        BRA notGt
gt      MOV R5, R3
notGt   CMP R3, R4
        BLT lt
        BRA notLt
lt      MOV R4, R3
notLt   BRA mmLoop
mmEnd   OUT R5
        OUT R4
        RET
dup     MOV R0, R7
        MOV R2, R6
        INP R1, 2
dupLoop LDR R3, 0(R0)
        STR R3, 0(R1)
        ADD R0, #1
        ADD R1, #1
        SUB R2, #1
        CMP R2, #0
        BEQ dupLpEnd
        BRA dupLoop
dupLpEnd RET

/*
for procedures:
JMS <label> -> jump to subroutine start
RET -> return from procedure
*/



